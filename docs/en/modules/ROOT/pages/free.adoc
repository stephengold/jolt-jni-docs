= Freeing native memory
:Cplusplus: C&#43;&#43;
:JPH: Jolt Physics
:page-pagination:
:Project: Jolt JNI
:ProjectAdj: Jolt-JNI
:Sport: Sport-Jolt

In long-running apps,
it's important to reclaim objects that are no longer in use,
lest the app run out of memory.
But it's even more important to ensure
objects don't get reclaimed while they *are* still in use!


== Native objects assigned to JVM objects

It's important to clearly distinguish JVM objects from native objects,
even though they tend to exist in a one-to-one relationship.

A handful of {ProjectAdj} classes are implemented entirely in Java, notably:
`Color`, `Float2`, `Float3`, `Plane`, `Quat`, `RVec3`,
`UVec4`, `Vec3`, `Vec4`, and `VertexList`.
These classes don't allocate any native memory;
instances exist entirely on the JVM's heap.
After such an object become unreachable, the JVM's garbage collector
automatically reclaims the object, freeing its memory.

{Project} also uses _direct buffers_, which *do* allocate native memory.
Such objects belong to subtypes of Java's `java.nio.Buffer` class.
Their native memory gets freed automatically
when the garbage collector
reclaims the JVM object to which the memory is assigned.

Aside from those special classes, however,
every JVM object in {Project} is an instance of `JoltPhysicsObject`,
implying it has a native object assigned to it.
For example, when a {ProjectAdj} app instantiates a matrix using `new Mat44()`,
both a JVM object and a native object are created.
How does the native object's memory get freed?


== Reclaiming native objects

{Project} provides several mechanisms
to reclaim native objects and free their memory.

{Cplusplus} convention dictates that when a class allocates memory,
it assumes responsibility for freeing that memory.
For native objects, this convention carries over into {Project}:
an app is solely responsible for all objects it creates explicitly.
(On the other hand, it cannot free the memory
of objects created internally by {Project} or {JPH}.)

=== Owned by a JVM object

In the simple case of an app explicitly instantiating a matrix
(using `matrix = new Mat44()`)
we say the JVM object _owns_ the native object assigned to it.
On other words, the JVM object is the native object's _owner_.

While it's possible to assign the same native object to multiple JVM objects,
only one JVM object (at most) can own a particular native object.

When a native object is owned by a JVM object,
its memory can be freed in 3 ways:

. explicitly using `matrix.close()`,
. implicitly by `AutoCloseable`
  (at the end of the `try` block in which `matrix` was instantiated), or
. automatically when the garbage collector reclaims the JVM object
  (provided a _cleaner task_ has been started
  by invoking `JoltPhysicsObject.startCleaner()`).

[IMPORTANT]
====
Explicitly closing a `JoltPhysicsObject` is risky
because it invalidates the native object, which might remain reachable.
This could lead to undefined behavior.
====

[TIP]
====
{Sport} automatically starts a cleaner task
for any app that extends `BasePhysicsApp`.
That's why none of the demos or sample applications invoke `close()`.
====

=== Contained objects

Ownership of a native object implies assignment.
However, assignment doesn't imply ownership.
Consider:

[source,java]
----
PhysicsSystem system = new PhysicsSystem();
system.init(/* ... */);
// ...
BodyLockInterface bli = system.getBodyLockInterface();
----

When the app invokes `getBodyLockInterface()`,
a new JVM object `bli` is returned.
However, `bli` refers to a pre-existing native object
(the one {JPH} allocated while initializing `system`).
The app cannot reclaim the native object assigned to `bli`
separately from the native object assigned to `system`.

On _contained objects_ like `bli`, `close()` is a no-op,
because the JVM object doesn't own its assigned native object.
However, closing the container would invalidate the contained object.
(In the example above, invoking `physicsSystem.close()`,
would invalidate `bli`.)

{Project}'s cleaner task is smart enough to delay reclaiming a container
while any reachable JVM object refers to that container's contents.
In the example above, as long as `bli` remains reachable,
it prevents cleaner threads from reclaiming `system`.

=== Refcounted objects

{JPH} uses reference counting to manage memory that can be shared among multiple
co-owners, and {ProjectAdj} exposes this feature.
The {ProjectAdj} classes that implement reference counting
are precisely those that implement the `RefTarget` interface.
These include `BaseCharacter`, `Constraint`, `ConstraintSettings`,
`GroupFilter`, `PhysicsMaterial`, `PhysicsScene`, `Ragdoll`, `Shape`,
`ShapeSettings`, and all their subclasses.

References are themselves instances of `JoltPhysicsObject`, of course.
(And please note that {ProjectAdj} reference counting is completely orthogonal
to Java references, strong, weak, or otherwise.)

The only way to reclaim a `RefTarget` native object
is to decrement its reference count from one to zero.
This implies creating one or more references
and then reclaiming them all, either explicitly, implicitly, or automatically.

To prevent the target native object from being reclaimed prematurely,
{Jolt} automatically creates a reference to it.
Invoking `close()` on the target object removes the automatic reference,
but the native target might remain active.
As long as one reference is active, the native target cannot be reclaimed.

[TIP]
====
You can disable reference counting on a particular target by
invoking `target.setEmbedded()`.
However, this is an irreversible action,
so if you plan to free the target's native memory,
you mustn't invoke `setEmbedded()`.
====

* The simplest way to create a counted reference
  is to invoke `target.toRef()` or `target.toRefC()`.
* As long as you retain a counted reference,
  you can always access its target by invoking `ref.getPtr()`.


== Summary

* Native objects are distinct from JVM objects.
* {Project} implements an optional cleaner task for reclaiming native objects
  and freeing their memory.
* Explicitly closing a `JoltPhysicsObject` is dangerous.
* An object responsible for reclaiming a native object
  it is said to _own_ that native object.
* Refcounted objects add a layer of indirection to managing native memory.
